'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AVLTree = function () {
    function AVLTree(value) {
        _classCallCheck(this, AVLTree);

        if (value) this.root = new Node(value);
    }

    _createClass(AVLTree, [{
        key: 'insert',
        value: function insert(value) {
            if (this.root) this.root.insert(value);else this.root = new Node(value);

            this.root.update();
            this.balance();

            return this;
        }
    }, {
        key: 'remove',
        value: function remove(value) {
            if (this.root) {
                this.root.remove(value, this);
                this.root.update();
            }
        }
    }, {
        key: 'rotateRight',
        value: function rotateRight(value) {
            this.root.get(value).rotateRight(this);
            this.root.update();
        }
    }, {
        key: 'rotateLeft',
        value: function rotateLeft(value) {
            this.root.get(value).rotateLeft(this);
            this.root.update();
        }
    }, {
        key: 'balance',
        value: function balance() {

            var unbalanceds = 0,
                nodeToRotate = null;

            this.root.posOrder(function (node) {
                if (Math.abs(node.balancing) >= 2) {
                    unbalanceds++;
                    if (unbalanceds == 1) nodeToRotate = node;
                }
            });

            if (unbalanceds == 0) return;

            if (nodeToRotate.balancing < 0) {
                if (nodeToRotate.left.balancing < 0) this.rotateRight(nodeToRotate.value);else this.doubleRotateLeft(nodeToRotate.value);
            } else {
                if (nodeToRotate.right.balancing > 0) this.rotateLeft(nodeToRotate.value);else this.doubleRotateRight(nodeToRotate.value);
            }

            this.balance();
        }
    }, {
        key: 'doubleRotateLeft',
        value: function doubleRotateLeft(value) {
            var node = this.root.get(value);
            node.left.rotateLeft(this);
            node.rotateRight(this);

            this.root.update();
        }
    }, {
        key: 'doubleRotateRight',
        value: function doubleRotateRight(value) {
            var node = this.root.get(value);
            node.right.rotateRight(this);
            node.rotateLeft(this);

            this.root.update();
        }
    }, {
        key: 'preOrder',
        value: function preOrder(callback) {
            this.root.preOrder(callback);
        }
    }]);

    return AVLTree;
}();

var Node = function () {
    function Node(value, parent) {
        _classCallCheck(this, Node);

        this.value = value;
        this.parent = parent;
        this.height = 0;

        if (parent) this.height = parent.height + 1;
    }

    _createClass(Node, [{
        key: 'updateLevel',
        value: function updateLevel() {
            this.level = this.parent ? 1 + this.parent.level : 0;
        }
    }, {
        key: 'updateHeight',
        value: function updateHeight() {
            var height = 0;

            if (this.left != null) {
                this.left.updateHeight();
                height = this.left.height;
            }
            if (this.right != null) {
                this.right.updateHeight();
                if (this.right.height > height) height = this.right.height;
            }
            this.height = height + 1;
        }
    }, {
        key: 'rotateLeft',
        value: function rotateLeft(tree) {

            /*
            4             6
            6    =>   4   7
            H   7        H
            */

            var child = this.right,
                hold = child.left;

            child.left = this;
            child.parent = this.parent;

            this.parent = child;
            this.right = hold;

            if (hold) hold.parent = this;

            if (child.parent != null) {
                var orientation = child.parent.left == this ? 'left' : 'right';
                child.parent[orientation] = child;
            } else {
                tree.root = child;
                child.parent = null;
            }
        }
    }, {
        key: 'rotateRight',
        value: function rotateRight(tree) {

            /*
            8         6
            6    =>   4   8
            4   H          H
            */

            var child = this.left,
                hold = child.right;

            child.right = this;
            child.parent = this.parent;

            this.parent = child;
            this.left = hold;

            if (hold) hold.parent = this;

            if (child.parent != null) {
                var orientation = child.parent.left == this ? 'left' : 'right';
                child.parent[orientation] = child;
            } else {
                tree.root = child;
                child.parent = null;
            }
        }
    }, {
        key: 'isLeaf',
        value: function isLeaf() {
            return !this.left && !this.right;
        }
    }, {
        key: 'countNodes',
        value: function countNodes() {
            if (this.isLeaf()) return 1;

            var counter = 1;
            if (this.left) counter += this.left.countNodes();
            if (this.right) counter += this.right.countNodes();
            return counter;
        }
    }, {
        key: 'remove',
        value: function remove(value, tree) {
            if (this.value == value) {
                var isRoot = !this.value.parent ? true : false;

                if (!isRoot) var orientation = this.parent.left == this ? 'left' : 'right';

                if (this.isLeaf()) {
                    if (isRoot) tree.root = null;else this.parent[orientation] = null;
                } else {
                    var number1 = 0,
                        number2 = 0;

                    if (this.left) number1 = this.left.countChilds();

                    if (this.right) number2 = this.right.countChilds();

                    if (number1 > number2) {
                        var antecessor = this.antecessor();

                        antecessor.left = this.left;

                        if (isRoot) tree.root = antecessor;else this.parent[orientation] = antecessor;
                    } else if (number2 >= number1) {
                        var sucessor = this.sucessor();

                        sucessor.right = this.right;

                        if (isRoot) tree.root = sucessor;else this.parent[orientation] = sucessor;
                    }
                }
            }

            if (value > this.value && this.right) this.right.remove(value, tree);

            if (value < this.value && this.left) this.left.remove(value, tree);
        }
    }, {
        key: 'countChilds',
        value: function countChilds() {
            return this.countNodes() - 1;
        }
    }, {
        key: 'posOrder',
        value: function posOrder(callback) {
            if (this.left) this.left.posOrder();
            if (this.right) this.right.posOrder();

            callback(this);
        }
    }, {
        key: 'update',
        value: function update() {
            this.preOrder(function (node) {
                node.updateLevel();
            });
            this.updateHeight();
            this.updateBalancing();
        }
    }, {
        key: 'updateBalancing',
        value: function updateBalancing() {
            var balancing = 0;

            if (this.right) {
                balancing = this.right.height;
                this.right.updateBalancing();
            }

            if (this.left) {
                balancing -= this.left.height;
                this.left.updateBalancing();
            }

            this.balancing = balancing;
        }
    }, {
        key: 'hasValue',
        value: function hasValue(value) {
            if (this.value == value) return true;

            if (value < this.value) if (this.left) return this.left.hasValue(value);else return false;

            if (value > this.value) if (this.right) return this.right.hasValue(value);else return false;
        }
    }, {
        key: 'insert',
        value: function insert(value) {
            if (value > this.value) if (this.right) this.right.insert(value);else this.right = new Node(value, this);

            if (value < this.value) if (this.left) this.left.insert(value);else this.left = new Node(value, this);

            this.update();

            return this;
        }
    }, {
        key: 'get',
        value: function get(value) {
            if (!this.hasValue(value)) return null;

            if (value == this.value) return this;

            if (value < this.value) return this.left.get(value);
            if (value > this.value) return this.right.get(value);
        }
    }, {
        key: 'biggest',
        value: function biggest() {
            if (this.right) return this.right.biggest();else return this;
        }
    }, {
        key: 'smallest',
        value: function smallest() {
            if (this.left) return this.left.smallest();else return this;
        }
    }, {
        key: 'successor',
        value: function successor() {
            return this.right ? this.right.smallest() : null;
        }
    }, {
        key: 'antecessor',
        value: function antecessor() {
            return this.left ? this.left.biggest() : null;
        }
    }, {
        key: 'preOrder',
        value: function preOrder(callback) {

            callback(this);

            if (this.left) this.left.preOrder(callback);

            if (this.right) this.right.preOrder(callback);
        }
    }, {
        key: 'posOrder',
        value: function posOrder(callback) {

            if (this.left) this.left.posOrder(callback);

            if (this.right) this.right.posOrder(callback);

            callback(this);
        }
    }, {
        key: 'inOrder',
        value: function inOrder(callback) {

            if (this.left) this.left.posOrder(callback);

            callback(this);

            if (this.right) this.right.posOrder(callback);
        }
    }, {
        key: 'getUnbalancedsfunction',
        value: function getUnbalancedsfunction() {
            var unbalanceds = [];
            this.update();
            this.preOrder(function (node) {
                if (Math.abs(node.balancing) >= 2) unbalanceds.push(node);
            });
            return unbalanceds;
        }
    }]);

    return Node;
}();

module.exports = AVLTree;